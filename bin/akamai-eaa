#!/usr/bin/env python

# Copyright 2020 Akamai Technologies, Inc. All Rights Reserved
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import print_function
import os
import sys
import json
import requests
import time
import base64
import hmac
import hashlib
import platform
from datetime import datetime
import logging
import six

from config import EdgeGridConfig

# If all parameters are set already, use them.  Otherwise
# use the config
config = EdgeGridConfig({"verbose": False}, "default")
verbose = getattr(config, "verbose", False)

SOURCE = "akamai-cli/eaa"
LOG = logging.getLogger(__name__)

datef = "%Y-%m-%d %H:%M"
collection_delay_minutes = 1
log_file = None
poll_interval_sec = 5
line_count = 0


class Etl(object):
    """ETL"""

    def __init__(self, api_version='v1'):
        self._api_ver = api_version
        self._content_type_json = {'content-type': 'application/json'}
        self._content_type_form = {'content-type': 'application/x-www-form-urlencoded'}
        self._headers = None

    def get_signature(self, access_key_id, secret_access_key):
        encoding = 'ascii'
        msg = "%s:%s" % (access_key_id, secret_access_key)
        signature = hmac.new(
            key=secret_access_key.encode(encoding),
            msg=msg.encode(encoding),
            digestmod=hashlib.sha256).digest()
        # Base64 encode the signature
        signature = base64.b64encode(signature)
        LOG.debug("Signature: %s" % signature.decode(encoding))
        return signature.decode(encoding)

    def ensure_signature_in_header(self, api_key, secret_key):
        signature = self.get_signature(access_key_id=api_key, secret_access_key=secret_key)
        self._headers = {'Authorization': 'Basic %s:%s' % (api_key, signature)}
        self._headers.update(self._content_type_json)

    def get_logs(self, api_key, secret_key, drpc_args, output):
        global line_count
        scroll_id = None
        try:
            """fetches the logs for given drpc args"""
            api_url = '{}/api/{}/analytics/ops'.format(
                config.base_url,
                self._api_ver
            )

            self.ensure_signature_in_header(api_key=api_key, secret_key=secret_key)
            LOG.debug("request headers: %s"  % self._headers)
            resp = requests.post(
                api_url,
                data=drpc_args,
                headers=self._headers,
                allow_redirects=False
            )

            if resp.status_code != requests.codes.ok:
                LOG.error("Invalid API response status code: %s" % resp.status_code)
                return None

            resj = resp.json()
            LOG.debug("JSON> %s" % resj)

            if 'message' in resj:
                msg = resj.get('message')[0][1]
                scroll_id = msg.get('scroll_id')
                LOG.debug("scroll_id: %s" % scroll_id)
                count = 0
                for timestamp, response in six.iteritems(msg):
                    try:
                        if not timestamp.isdigit():
                            LOG.debug("Ignored timestamp '%s': %s" % (timestamp, response))
                            continue
                        LOG.debug("flog is %s" % type(response['flog']).__name__)
                        LOG.debug("Scanned timestamp: %s" % timestamp)
                        gmttime = datetime.fromtimestamp(int(timestamp)/1000)
                        if isinstance(response, dict) and 'flog' in response:
                            out.write("%s\n" % ' '.join([gmttime.isoformat(), response['flog']]))
                            line_count += 1
                            LOG.debug("### flog ## %s" % response['flog'])
                            count += 1
                    except Exception:
                        LOG.exception("error parsing response")

            else:
                LOG.error('Error: no data(message) in response.')
                LOG.error(drpc_args)
                LOG.error(json.dumps(resj))
            resp.close()
        except Exception as e:
            if "resp" in locals():
                LOG.debug("resp.status_code %s" % resp.status_code)
                LOG.debug("resp.text %s" % resp.text)
            LOG.error(drpc_args)
            LOG.exception("Exception in get_logs")
        return scroll_id


def log_level():
    if config.debug:
        return logging.DEBUG
    elif config.verbose:
        return logging.INFO
    else:
        return logging.ERROR


if __name__ == "__main__":

    api_key = config.eaa_api_key
    secret_key = config.eaa_api_secret

    logging.basicConfig(filename=log_file, level=log_level(),
        format='%(asctime)s [%(levelname)s] %(message)s')

    etl = Etl();

    LOG.debug("Python %s" % platform.python_version())
    LOG.info("PID: %s" % os.getpid())

    if config.output is None:
        out = sys.stdout
    else:
        LOG.info("Output file: %s" % config.output)
        LOG.info("Poll interval: %s seconds" % poll_interval_sec)
        out = open(config.output, 'w+')

    try:
        while True:
            # end time in milliseconds
            ets = int(time.mktime(time.localtime()) * 1000 - (collection_delay_minutes * 60 * 1000))
            # start time in milliseconds
            sts = int(ets - (poll_interval_sec * 1000) - (collection_delay_minutes * 60 * 1000))

            LOG.debug("Fetching log[%s] from %s to %s..." % (config.log_type, sts, ets))

            if config.log_type == "access":
                # Use scroll paging
                drpc_args = '{"sts":'+ str(sts) + ',"ets":'+ str(ets) + \
                            ',"metrics":"logs","es_fields":"flog","limit":"1000","sub_metrics":"scroll","source": "%s"}' % SOURCE
                scroll_id = etl.get_logs(api_key, secret_key, drpc_args, out)
                # Check for scroll_id to issue another request
                while (scroll_id != None):
                    drpc_args = '{"sts":'+ str(sts) +',"ets":'+ str(ets) + \
                    ',"metrics":"logs","es_fields":"flog","limit":"1000","sub_metrics":"scroll","source":"' + SOURCE + '","scroll_id":"'+scroll_id+'"}'
                    scroll_id = etl.get_logs(api_key, secret_key, drpc_args, out)

                out.flush()

            elif config.type == "admin":
                pass
            else:
                raise Exception("Not supported log type: %s" % config.type)

            if not config.tail:
                break
            else:
                LOG.debug("Now waiting %s seconds..." % poll_interval_sec)
                time.sleep(poll_interval_sec)
    except KeyboardInterrupt as ki:
        LOG.info("Keyboard interupt")
    finally:
        if out is not None and out != sys.stdout:
            LOG.debug("Closing output file...")
            out.close()

        LOG.info("%s log lines were fetched." % line_count)
