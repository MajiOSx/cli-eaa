#!/usr/bin/env python3

# Copyright 2020 Akamai Technologies, Inc. All Rights Reserved
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Load Akamai Enteprise Application Access access logs
# Original author: <androcho@akamai.com> based on Splunk app

from __future__ import print_function
import os
import sys
import json
import requests
import time
import base64
import hmac
import hashlib
import platform
from datetime import datetime
import logging
import signal
from threading import Event
import util
import fnmatch
from urllib.parse import urljoin
from enum import Enum
import re

# 3rd party
import six
from akamai.edgegrid import EdgeGridAuth, EdgeRc
from config import EdgeGridConfig

__version__ = '0.2.1'

# If all parameters are set already, use them.  Otherwise
# use the config
config = EdgeGridConfig({'verbose': False}, 'default')
verbose = getattr(config, 'verbose', False)

SOURCE = 'akamai-cli/eaa'
LOG_FMT = '%(asctime)s [%(levelname)s] %(threadName)s %(message)s'

log_file = None
stop_event = Event()


class cli:
    """
    Utility methods for the CLI.
    """

    @staticmethod
    def print(s):
        sys.stdout.write("%s\n" % s)

    @staticmethod
    def header(s):
        sys.stderr.write("%s\n" % s)

    @staticmethod
    def footer(s):
        sys.stderr.write("%s\n" % s)

    @staticmethod
    def log_level():
        if config.debug:
            return logging.DEBUG
        elif config.verbose:
            return logging.INFO
        else:
            return logging.ERROR

    @staticmethod
    def exit_gracefully(signum, frame):
        logging.info("Stop due to SIGTERM or SIGINT signal received")
        stop_event.set()


class EAALegacyAuth(requests.auth.AuthBase):
    """
    EAA legacy API authentication for Requests
    """
    def __init__(self, key, secret):
        self._key = key
        self._secret = secret
        self._signature = self.get_signature()

    def get_signature(self):
        encoding = 'ascii'
        msg = "%s:%s" % (self._key, self._secret)
        signature = hmac.new(
            key=self._secret.encode(encoding),
            msg=msg.encode(encoding),
            digestmod=hashlib.sha256).digest()
        signature = base64.b64encode(signature)
        return signature.decode(encoding)

    def __call__(self, r):
        r.headers.update({'Authorization': 'Basic %s:%s' % (self._key, self._signature)})
        return r


class EAAInvalidMoniker(Exception):
    pass


class EAAItem(object):
    """
    Representation of an EAA object.
    """
    SEP = '://'

    def __init__(self, obj_url):
        if not isinstance(obj_url, six.string_types):
            raise TypeError('obj_url must be a string')
        if EAAItem.SEP not in obj_url:
            raise EAAInvalidMoniker('Invalid EAA Object URL %s' % obj_url)
        scanned_type, scanned_uuid = obj_url.split(EAAItem.SEP)
        self.objtype = scanned_type
        self.uuid = scanned_uuid

    def __repr__(self):
        return self.objtype + EAAItem.SEP + self.uuid

    def __str__(self):
        return self.__repr__()


class BaseAPI(object):

    class API_Version(Enum):
        "API backend, either Legacy or {OPEN} API (support introduced in 2020 for EAA)."
        Legacy = 1
        OpenAPI = 2

    def __init__(self, config=None, api=API_Version.Legacy):

        self._config = config
        edgerc = EdgeRc(config.edgerc)
        section = config.section

        if api == self.API_Version.Legacy:  # Prior to {OPEN} API
            self._api_ver = api
            self._content_type_json = {'content-type': 'application/json'}
            self._content_type_form = \
                {'content-type': 'application/x-www-form-urlencoded'}
            self._headers = None
            # self._baseurl = 'https://%s' % edgerc.get(section, 'host')
            self._baseurl = 'https://%s/api/v1/' % edgerc.get(section, 'eaa_api_host')
            self._session = requests.Session()
            self._session.auth = EAALegacyAuth(
                edgerc.get(section, 'eaa_api_key'),
                edgerc.get(section, 'eaa_api_secret')
            )
        else:  # {OPEN} API
            # TODO handle ambiguity when multiple contract ID are in use
            self._baseurl = 'https://%s/crux/v1/' % edgerc.get(section, 'host')
            self._session = requests.Session()
            self._session.auth = EdgeGridAuth.from_edgerc(edgerc, section)

        logging.info("Initialized with base_url %s" % self._baseurl)

    def build_params(self, params=None):
        default_params = {}
        if hasattr(self._config, 'contract_id') and self._config.contract_id:
            default_params.update({'contractId': self._config.contract_id})
        if isinstance(params, dict):
            default_params.update(params)
        return default_params

    def get(self, url_path, params=None):
        """
        Send a GET reques to the API.
        """
        url = urljoin(self._baseurl, url_path)
        logging.info("API URL: %s" % url)
        response = self._session.get(url, params=self.build_params(params))
        logging.info("BaseAPI: GET response is HTTP %s" % response.status_code)
        if response.status_code != 200:
            logging.info("BaseAPI: GET response body: %s" % response.text)
        return response

    def post(self, url_path, json=None, params=None):
        url = urljoin(self._baseurl, url_path)
        logging.info("API URL: %s" % url)
        response = self._session.post(url, json=json, params=self.build_params(params))
        logging.info("BaseAPI: POST response is HTTP %s" % response.status_code)
        if response.status_code != 200:
            logging.info("BaseAPI: POST response body: %s" % response.text)
        return response

    def put(self, url_path, json=None):
        url = urljoin(self._baseurl, url_path)
        logging.info("API URL: %s" % url)
        response = self._session.put(url, json=json)
        logging.info("BaseAPI: PUT response is HTTP %s" % response.status_code)
        if response.status_code != 200:
            logging.info("BaseAPI: PUT response body: %s" % response.text)
        return response

    def delete(self, url_path, json=None, params=None):
        url = urljoin(self._baseurl, url_path)
        logging.info("API URL: %s" % url)
        response = self._session.delete(url, json=json)
        logging.info("BaseAPI: DELETE response is HTTP %s" % response.status_code)
        if response.status_code != 200:
            logging.info("BaseAPI: DELETE response body: %s" % response.text)
        return response


class SearchAPI(BaseAPI):
    """
    Search EAA applications
    2020-08-07: migrated to {OPEN} API
    """

    SCAN_LIMIT = 1000

    def __init__(self, config):
        super(SearchAPI, self).__init__(config, api=BaseAPI.API_Version.OpenAPI)

    def search_app(self, search_pattern):
        url_params = {'limit': SearchAPI.SCAN_LIMIT}
        search_app = self.get('mgmt-pop/apps', params=url_params)
        self.process_response(search_app.json(), search_pattern)

    def process_response(self, data, search_pattern):
        app_found = 0
        if data.get("meta"):
            app_count = data.get("meta").get("total_count")

            for a in data.get('objects', []):
                if not search_pattern or (
                    search_pattern and (
                        fnmatch.fnmatch(a.get('name') or "", "*%s*" % search_pattern) or
                        fnmatch.fnmatch(a.get('host') or "", "*%s*" % search_pattern) or
                        fnmatch.fnmatch(a.get('cname') or "", "*%s*" % search_pattern)
                    )
                ):
                    cli.print('app://%s,%s,%s,%s,%s,%s' % (
                        a.get('uuid_url'),
                        ApplicationAPI.Type(a.get('app_type')).name,
                        a.get('name'),
                        a.get('host'),
                        a.get('cname'),
                        ApplicationAPI.Status(a.get('app_status')).name))
                    app_found += 1
            # Footer
            if not config.batch:
                if app_found != app_count:
                    cli.footer("Found %s app(s), total %s app(s)" % (app_found, app_count))
                else:
                    cli.footer("%s app(s)" % app_count)


class DirectoryAPI(BaseAPI):
    """
    Interact with EAA directory configurations.
    """
    # class DirectoryType(Enum):
    #     CloudDirectory  7
    #     LDAP: 10,
    #     ActiveDirectory: 108

    class DirectoryStatus(Enum):
        Status3 = 3

    def __init__(self, config, directory_moniker=None):
        super(DirectoryAPI, self).__init__(config, BaseAPI.API_Version.OpenAPI)
        self._directory = None
        self._directory_id = None
        if directory_moniker:
            self._directory = EAAItem(directory_moniker)
            self._directory_id = self._directory.uuid

    def list_groups(self):
        url_params = {'limit': 0}
        url = 'mgmt-pop/directories/{directory_id}/groups'.format(directory_id=self._directory_id)
        if self._config.search_pattern:
            url_params = url_params.update({'q': self._config.search_pattern})
        resp = self.get(url, params=url_params)
        resj = resp.json()
        for u in resj.get('objects'):
            print('group://{uuid},{name}'.format(
                uuid=u.get('uuid_url'),
                name=u.get('name')
            ))

    def list_users(self):
        url_params = {'limit': 0}
        url = 'mgmt-pop/users'
        if self._config.search_pattern:
            url_params = url_params.update({'q': self._config.search_pattern})
        resp = self.get(url, params=url_params)
        resj = resp.json()
        for u in resj.get('objects'):
            print("user://{uuid},{fn},{ln}".format(
                uuid=u.get('uuid_url'),
                fn=u.get('first_name'),
                ln=u.get('last_name')
            ))

    def list_directories(self):
        if self._directory_id:
            if self._config.users:
                if self._config.search_pattern and not self._config.batch:
                    cli.header("# list users matching %s in %s" % (self._config.search_pattern, self._directory_id))
                self.list_users()
            elif self._config.groups:
                if self._config.search_pattern and not self._config.batch:
                    cli.header("# list groups matching %s" % self._config.search_pattern)
                self.list_groups()
        else:
            resp = self.get("mgmt-pop/directories")
            if resp.status_code != 200:
                logging.error("Error retrieve directories (%s)" % resp.status_code)
            resj = resp.json()
            # print(resj)
            if not self._config.batch:
                cli.header("#dir_id,dir_name,status,user_count")
            total_dir = 0
            for total_dir, d in enumerate(resj.get("objects"), start=1):
                cli.print("dir://{dirid},{name},{status},{user_count}".format(
                    dirid=d.get("uuid_url"),
                    name=d.get("name"),
                    status=d.get("directory_status"),
                    user_count=d.get("user_count"))
                )
            if total_dir == 0:
                cli.footer("No EAA Directory configuration found.")
            elif total_dir == 1:
                cli.footer("One EAA Directory configuration found.")
            else:
                cli.footer("%d EAA Directory configurations found." % total_dir)

    def delgroup(self, group_id):
        raise NotImplementedError("Group deletion is not implemented")

    def deloverlaygroup(self, group_id):
        raise NotImplementedError("Group Overlay deletion is not implemented")
        url = "mgmt-pop/directories/{directory_id}/groups/{group_id}".format(
                directory_id=self._directory_id,
                group_id=group_id
            )
        self.delete(url)

    def addoverlaygroup(self, groupname):
        url = "mgmt-pop/directories/{directory_id}/groups".format(directory_id=self._directory_id)
        resp = self.post(url, json={"status": 1, "group_type": 4, "name": groupname})
        if resp.status_code != 200:
            logging.error("Error adding group to directory %s" % self._directory_id)
        else:
            cli.footer("Overlay group %s added to directory %s" % (groupname, self._directory_id))

    @staticmethod
    def groupname_from_dn(dn):
        """
        Extract the group name from a full Distinguished Name string.
        Reference: https://regexr.com/3l4au
        """
        regexp = '^(?:(?P<cn>CN=(?P<name>[^,]*)),)?(?:(?P<path>(?:(?:CN|OU)=[^,]+,?)+),)?(?P<domain>(?:DC=[^,]+,?)+)$'
        matches = re.search(regexp, dn)
        if matches:
            return matches.group('name')
        else:
            return False

    def addgroup(self, dn):
        """
        Add a group to EAA Directory configuration.
        :param dn: Distiguished Name of the group
                   Example: CN=Print Operators,CN=Builtin,DC=AKAMAIDEMO,DC=NET
        """
        url = "mgmt-pop/directories/{directory_id}/groups".format(directory_id=self._directory_id)
        for scanned_dn in util.argument_tolist((dn,)):
            group = DirectoryAPI.groupname_from_dn(scanned_dn)
            if group:
                logging.debug("Adding group %s" % (scanned_dn))
                resp = self.post(url, json={"name": group, "dn": scanned_dn})
                if resp.status_code != 200:
                    logging.error(resp.status_code)
            else:
                logging.warn("Invalid DN: %s" % scanned_dn)

    def synchronize(self):
        print("Synchronize directory %s..." % self._directory_id)
        response = self.post("mgmt-pop/directories/{dirId}/sync".format(dirId=self._directory_id))
        if response.status_code == 200 and not self._config.batch:
            print("Directory %s synchronization requested." % self._directory_id)


class ApplicationAPI(BaseAPI):
    """
    EAA Applications
    Only supported with {OPEN} API
    """

    class Status(Enum):
        NotReady = 1
        Ready = 2
        Pending = 3
        Deployed = 4
        Failed = 5
        CloudDeployed = 6
        ConnectorDeploy = 7

    class Type(Enum):
        Hosted = 1
        SaaS = 2
        Bookmark = 3
        Tunnel = 4
        ETP = 5

    def __init__(self, config):
        super(ApplicationAPI, self).__init__(config, api=BaseAPI.API_Version.OpenAPI)

    def process_command(self):
        """
        Process command passed from the CLI.
        """
        applications = list()
        appgroups = list()
        if self._config.application_id == '-':
            for line in sys.stdin:
                scanned_items = line.split(',')
                if len(scanned_items) == 0:
                    logging.warning("Cannot parse line: %s" % line)
                    continue
                try:
                    scanned_obj = EAAItem(scanned_items[0])
                    if scanned_obj.objtype == 'app':
                        applications.append(scanned_obj)
                    elif scanned_obj.objtype == 'appgrp':
                        appgroups.append(scanned_obj)
                except EAAInvalidMoniker:
                    logging.warning("Invalid application moniker: %s" % scanned_items[0])
        else:
            applications.append(EAAItem(config.application_id))

        if config.action == "deploy":
            for a in applications:
                self.deploy(a)
                print("Application %s deployment requested, it may take a few minutes before it gets live." % a)
        elif config.action == "add_dnsexception":
            for a in applications:
                self.add_dnsexception(a)
        elif config.action == "del_dnsexception":
            for a in applications:
                self.del_dnsexception(a)
        elif config.action == 'viewgroups':
            for a in applications:
                self.loadgroups(a)
        elif config.action == 'delgroup':
            for ag in appgroups:
                self.delgroup(ag)
        else:  # view by default
            for a in applications:
                app_config = self.load(a)
                print(json.dumps(app_config))
                # print(app_config)

    def load(self, app_moniker):
        url_params = {'expand': 'true', 'expand_sdk': 'true'}
        url = 'mgmt-pop/apps/{applicationId}'.format(applicationId=app_moniker.uuid)
        result = self.get(url, params=url_params)
        return result.json()

    def loadgroups(self, app_moniker):
        """Directory+Groups allowed to access this application."""
        url_params = {'limit': 0, 'expand': 'true', 'expand_sdk': 'true'}
        url = 'mgmt-pop/apps/{applicationId}/groups'.format(applicationId=app_moniker.uuid)
        result = self.get(url, url_params)
        count = 0
#        print("RAW DATA: %s" % result.json())
        allowed_groups = result.json().get('objects')
        if not self._config.batch:
            print("# Allowed Groups to access app %s" % app_moniker)
            print("# appgroup_id,group_id,group_name,dir_name,mfa")
        for count, group in enumerate(allowed_groups, start=1):
            association = group.get('resource_uri', {}).get('href')
            print("appgrp://{appgroup_id},grp://{group_id},{name},{dir_name},{mfa}".format(
                appgroup_id=association.split('/')[-1],
                group_id=group.get('group').get('group_uuid_url'),
                name=group.get('group').get('name'),
                dir_name=group.get('group').get('dir_name'),
                mfa=group.get('enable_mfa')
            ))

        if not self._config.batch:
            print("# %s groups configured to access application %s" % (count, app_moniker))
        return allowed_groups

    def delgroup(self, appgroup_moniker):
        print("Delete App-Group association %s..." % appgroup_moniker)
        deletion = self.post('mgmt-pop/appgroups', params={'method': 'DELETE'},
                             json={'deleted_objects': [appgroup_moniker.uuid]})
        if deletion.status_code == 200:
            print("Association %s deleted." % appgroup_moniker)

    def save(self, app_moniker, app_config):
        """
        Save/update an EAA application configuration.
        """
        update = self.put(
            'mgmt-pop/apps/{applicationId}'.format(applicationId=app_moniker.uuid),
            json=app_config
        )
        logging.info("Update app response: %s" % update.status_code)
        logging.info("Update app response: %s" % update.text)
        if update.status_code != 200:
            exit(2)

    def add_dnsexception(self, app_moniker):
        logging.info("Adding DNS exception: %s" % config.exception_fqdn)
        appcfg = self.load(app_moniker)
        dns_exceptions = set(appcfg.get('advanced_settings', {}).get('domain_exception_list').split(','))
        dns_exceptions |= set(config.exception_fqdn)
        appcfg["advanced_settings"]["domain_exception_list"] = ','.join(dns_exceptions)
        self.save(app_moniker, appcfg)

    def del_dnsexception(self, app_moniker):
        logging.info("Remove DNS exception: %s" % config.exception_fqdn)
        pass

    def deploy(self, app_moniker):
        """
        Deploy an EAA application.
        """
        if not isinstance(app_moniker, EAAItem):
            raise TypeError("Deploy expect and EAAItem, %s provided" % type(app_moniker))
        if app_moniker.objtype != 'app':
            raise ValueError("EAAItem object must be app, %s found" % app_moniker.objtype)
        deploy = self.post('mgmt-pop/apps/{applicationId}/deploy'.format(applicationId=app_moniker.uuid))
        logging.info("ApplicationAPI: deploy app response: %s" % deploy.status_code)
        if deploy.status_code != 200:
            logging.error(deploy.text)


class EventLogAPI(BaseAPI):
    """
    EAA logs, this is using the legacy API
    """

    #: Pull interval when using the tail mode
    PULL_INTERVAL_SEC = 15
    COLLECTION_DELAY_MINUTES = 0

    class EventType(Enum):
        USER_ACCESS = "access"
        ADMIN = "admin"

    ADMINEVENT_API = "adminevents-reports/ops/splunk-query"
    ACCESSLOG_API = "analytics/ops"

    def __init__(self, config):
        super(EventLogAPI, self).__init__(config, api=BaseAPI.API_Version.Legacy)
        self._content_type_json = {'content-type': 'application/json'}
        self._content_type_form = {'content-type': 'application/x-www-form-urlencoded'}
        self._headers = None
        self._output = config.output
        self.line_count = 0

    def get_api_url(self, logtype):
        if logtype == self.EventType.ADMIN:
            return self.ADMINEVENT_API
        else:
            return self.ACCESSLOG_API

    def get_logs(self, drpc_args, logtype=EventType.USER_ACCESS, output=sys.stdout):
        """
        Fetch the logs, by default the user access logs.
        """
        if not isinstance(logtype, self.EventType):
            raise ValueError("Unsupported log type %s" % logtype)

        scroll_id = None
        try:
            # Fetches the logs for given drpc args
            resp = self.post(self.get_api_url(logtype), json=drpc_args)
            if resp.status_code != requests.codes.ok:
                logging.error("Invalid API response status code: %s" % resp.status_code)
                return None

            resj = resp.json()
            logging.debug("JSON> %s" % json.dumps(resj, indent=2))

            if 'message' in resj:
                # Get msg and scroll_id based on the type of logs
                # Since it is two different API in the back-end
                if logtype == self.EventType.USER_ACCESS:
                    msg = resj.get('message')[0][1]
                    scroll_id = msg.get('scroll_id')
                elif logtype == self.EventType.ADMIN:
                    msg = resj.get('message')
                    if 'scroll_id' in msg.get('metadata'):
                        scroll_id = msg.get('metadata').get('scroll_id')
                else:
                    raise NotImplementedError("Doesn't support log type %s" % logtype)

                logging.debug("scroll_id: %s" % scroll_id)
                count = 0

                if logtype == self.EventType.USER_ACCESS:
                    for timestamp, response in six.iteritems(msg):
                        try:
                            if not timestamp.isdigit():
                                logging.debug("Ignored timestamp '%s': %s" % (timestamp, response))
                                continue
                            logging.debug("flog is %s" % type(response['flog']).__name__)
                            logging.debug("Scanned timestamp: %s" % timestamp)
                            local_time = datetime.fromtimestamp(int(timestamp)/1000)
                            if isinstance(response, dict) and 'flog' in response:
                                line = "%s\n" % ' '.join([local_time.isoformat(), response['flog']])
                                output.write(line)
                                logging.debug("### flog ## %s" % response['flog'])
                                self.line_count += 1
                                count += 1
                        except Exception:
                            logging.exception("Error parsing access log line")
                elif logtype == self.EventType.ADMIN:
                    for item in msg.get('data'):
                        try:
                            local_time = datetime.fromtimestamp(int(item.get('ts')/1000))
                            line = u"{},{}\n".format(local_time.isoformat(), item.get('splunk_line'))
                            self._output.write(line.encode("utf8"))
                            self.line_count += 1
                            count += 1
                        except Exception as e:
                            logging.exception('Error parsing admin log line: %s, content: %s' %
                                              (e, item.get('splunk_line')))
            else:
                logging.error('Error: no data(message) in response.')
                logging.error(drpc_args)
                logging.error(json.dumps(resj))
            resp.close()
        except Exception:
            if "resp" in locals():
                logging.debug("resp.status_code %s" % resp.status_code)
                logging.debug("resp.text %s" % resp.text)
            logging.error(drpc_args)
            logging.exception("Exception in get_logs")
        return scroll_id

    @staticmethod
    def date_boundaries():
        # end time in milliseconds, now minus collection delay
        ets = int(time.mktime(time.localtime()) * 1000 - (EventLogAPI.COLLECTION_DELAY_MINUTES * 60 * 1000))
        if not config.tail and config.end:
            ets = config.end * 1000
        # start time in milliseconds: end time minus poll interval
        sts = int(ets - (EventLogAPI.PULL_INTERVAL_SEC * 1000))
        if not config.tail and config.start:
            sts = config.start * 1000
        return ets, sts

    def fetch_logs(self, exit_fn, stop_event):
        """
        Fetch all logs
        :param exit_fn: function to call upon SIGTERM and SIGINT
        """

        log_type = self.EventType(config.log_type)
        logging.info(log_type)
        signal.signal(signal.SIGTERM, exit_fn)
        signal.signal(signal.SIGINT, exit_fn)

        logging.info("PID: %s" % os.getpid())
        logging.info("Poll interval: %s seconds" % EventLogAPI.PULL_INTERVAL_SEC)
        try:
            if self._output is None:
                out = sys.stdout
            else:
                logging.info("Output file: %s" % config.output)
                out = open(self._output, 'w+')
            while True:
                ets, sts = EventLogAPI.date_boundaries()
                s = time.time()
                logging.info("Fetching log[%s] from %s to %s..." % (log_type, sts, ets))
                scroll_id = None
                while (True):
                    drpc_args = {
                        'sts': str(sts),
                        'ets': str(ets),
                        'metrics': 'logs',
                        'es_fields': 'flog',
                        'limit': '1000',
                        'sub_metrics': 'scroll',
                        'source': SOURCE,
                    }
                    if scroll_id is not None:
                        drpc_args.update({'scroll_id': str(scroll_id)})
                    scroll_id = self.get_logs(drpc_args, log_type, out)
                    out.flush()
                    if scroll_id is None:
                        break
                if not config.tail:
                    if not config.batch:
                        print("# Start: %s" % time.strftime('%m/%d/%Y %H:%M:%S UTC', time.gmtime(sts/1000.)))
                        print("# End: %s" % time.strftime('%m/%d/%Y %H:%M:%S UTC', time.gmtime(ets/1000.)))
                        print("# Total: %s event(s)" % self.line_count)
                    break
                else:
                    elapsed = time.time() - s
                    logging.debug("Now waiting %s seconds..." % (EventLogAPI.PULL_INTERVAL_SEC - elapsed))
                    stop_event.wait(EventLogAPI.PULL_INTERVAL_SEC - elapsed)
                    if stop_event.is_set():
                        break
        except Exception:
            logging.exception("General exception while fetching EAA logs")
        finally:
            if out is not None and out != sys.stdout:
                logging.debug("Closing output file...")
                out.close()
            logging.info("%s log lines were fetched." % self.line_count)


class ConnectorAPI(BaseAPI):

    def __init__(self, config):
        super(ConnectorAPI, self).__init__(config, api=BaseAPI.API_Version.OpenAPI)

    def list(self):
        url_params = {'expand': 'true', 'limit': 0}
        data = self.get('mgmt-pop/agents', params=url_params)
        connectors = data.json()
        total_con = 0
        cli.print('#Connector-id,name,reachable,status,version,privateip,publicip,debug')
        for total_con, c in enumerate(connectors.get('objects', {}), start=1):
            cli.print("con://{con_id},{name},{reachable},{status},{version},{privateip},{publicip},{debugchan}".format(
                con_id=c.get('uuid_url'),
                name=c.get('name'),
                reachable=c.get('reach'),
                status=c.get('status'),
                version=c.get('agent_version').replace('AGENT-', '').strip(),
                privateip=c.get('private_ip'),
                publicip=c.get('private_ip'),
                debugchan='Y' if c.get('debug_channel_permitted') else 'N'
            ))
        cli.footer("Total %s connector(s)" % total_con)



if __name__ == "__main__":

    logging.basicConfig(filename=log_file, level=cli.log_level(), format=LOG_FMT)
    logging.debug("Python %s" % platform.python_version())

    try:
        if config.command == "version":
            print(__version__)
        elif config.command in ("log", "l"):
            events = EventLogAPI(config)
            events.fetch_logs(cli.exit_gracefully, stop_event)
        elif config.command in ("search", "s"):
            s = SearchAPI(config)
            s.search_app(config.pattern)
        elif config.command in ("dir", "d"):
            if config.action is None or config.action == "list":
                directory_id = None
                if hasattr(config, 'directory_id'):
                    directory_id = config.directory_id
                d = DirectoryAPI(config, directory_id)
                d.list_directories()
            else:
                d = DirectoryAPI(config, config.directory_id)
                if config.action == "sync":
                    d.synchronize()
                elif config.action == "addgroup":
                    d.addgroup(config.group)
                elif config.action == "addovlgroup":
                    d.addoverlaygroup(config.group)
                else:
                    raise Exception("Unsupported directory action: %s" % config.action)
        elif config.command in ("app", "a"):
            a = ApplicationAPI(config)
            a.process_command()
        elif config.command in ("connector", "c"):
            c = ConnectorAPI(config)
            c.list()
        else:
            config.parser.print_help()
            sys.exit(1)
    except KeyboardInterrupt:
        print("cli-eaa interrupted.")
        sys.exit(2)
    except Exception:
        logging.exception("cli-eaa general exception")
        sys.exit(200)

# end of file
